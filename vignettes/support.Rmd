<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Meaningful Spatial Statistics: an introduction}
\usepackage[utf8]{inputenc}
-->
# Meaningful Spatial Statistics: The `mss` Package

This vignette introduces an R package for meaningful spatial statistics,
```{r}
library(mss)
```

The package introduces three classes for spatial data: `SpatialField`
for representing geostatistical data, `SpatialEntities` for
point patterns, and `SpatialAggregation` for lattice (areal)
data. 

## `Window`: field domain or observation windows
`SpatialField` and `SpatialEntities` contain a `Window`,
representing the domain of the field, or the window of observation
for a point pattern.  

The window class defines an area: 
```{r}
showClass("Window")
```
The area can be represented either by a grid, as in
```{r}
library(sp)
demo(meuse, ask = FALSE, echo = FALSE)
w2 = Window(meuse.grid) # note the grid is passed, not the polygons
```
or by a polygon or set of polygons, as in
```{r}
w1 = Window(meuse.area)
```

## `SpatialField`: geostatistical data
SpatialFields represent _continuous_ functions, which over a
domain $D$ have a value at every _point_ $s \in D$.
```{r}
showClass("SpatialField")
```
### Fields from points
Observations on fields variables are often done on irregular
point locations. Such a field variable is created from a
`SpatialPointsDataFrame` object:
```{r}
sf = SpatialField(meuse, meuse.grid)
```
where, here, `meuse.grid` defines the domain for the
field. Alternatively, _point observations_ can be gridded, and
defined as a field by
```{r}
sf = SpatialField(meuse.grid, meuse.grid, cellsArePoints = TRUE)
```
Note that the first argument defines the point observations, and 
the second argument the domain: the first argument is treated as
a (gridded) set of points (grid cell centres), the second as a 
gridded set of areas (cells).
### Fields from grids, grid cells representing constant areas
We can alternatively assume that each grid cell represents an area
with constant point values. Such a field is defined by:
```{r}
sf = SpatialField(meuse.grid, meuse.grid, cellsArePoints = FALSE)
```
This field is completely known, for every point location. Note
that grid cell values are _constant throughout the cell_, and are
not conceived as cell aggregate (e.g. average, or otherwise
convoluted) values. For that case, `SpatialAggregates` are used.

### Fields from lines and polygons
Sets of points can not only be defined by grid cells, but also
through lines, or polygons. For instance, points on a contour
line could form a sample of a field:
```{r}
library(maptools)
library(rgeos)
cl = ContourLines2SLDF(contourLines(as.image.SpatialGridDataFrame(
  meuse.grid["dist"])))
proj4string(cl) = CRS(proj4string(meuse.grid))
sf.lines = SpatialField(cl, meuse.grid)
```
or, alternatively, as a set of polygons; in this example, a single
polygon with a constant value:
```{r}
pol = addAttrToGeom(meuse.area, data.frame(value = 3), FALSE)
sf.pol = SpatialField(pol, meuse.area)
```

```{r}
showClass("SpatialEntities")
```

```{r}
showClass("SpatialAggregation")
```

## Interpolation

### interpolation of point support data
We can predict to points, laid out regularly, inside a polygon
```{r}
m = SpatialField(meuse, meuse.area) # data are point support
i1 = interpolate(log(zinc)~1, m) # interpolate from point TO point support
spplot(i1, "var1.pred")
```
To show that these really concern points, plotting for a smaller region gives
actual point symbols:
```{r}
spplot(i1, "var1.pred", xlim = c(179440,180560), ylim = c(330000,331000))

```

or we can predict the polygon area mean value:
```{r}
library(rgeos)
m2 = SpatialAggregation(meuse.area)
i2 = interpolate(log(zinc)~1, m, m2) # interpolate from point TO polygon support
i2$var1.pred # a single value, estimate of mean for the whole area
mean(log(m$zinc)) # sample mean
mean(i1$var1.pred) # mean of predictions, similar to i2$var1.pred
```
We can repeat this with a domain, defined by the `meuse.grid` object, by
predicting to point support values for points on a grid
```{r}
m = SpatialField(meuse, meuse.grid)
i3 = interpolate(log(zinc)~1, m)
print(as(i3[1:3,], "data.frame"), digits = 10) # point support
```
or predict values for cell means:
```{r}
m4 = SpatialAggregation(meuse.grid)
i4 = interpolate(log(zinc)~1, m, m4) # interpolate from point TO feature (cell) support
print(as(i4[1:3,], "data.frame"), digits = 10) # grid cells support
spplot(i4, "var1.pred")
```

### Support of the feature
Suppose we have grid data on a 3 x 3 grid, and
want to estimate on a new location, indicated by a red
circle:
```{r}
set.seed(131)
gt = GridTopology(cellcentre.offset = c(0,0), cellsize = c(1,1), cells.dim = c(3,3))
sgdf = SpatialGridDataFrame(SpatialGrid(gt), 
	data.frame(r = round(runif(9, max = 10), 1)))
plot(as(sgdf, "SpatialPolygons"), axes = TRUE)
text(coordinates(sgdf), labels = sgdf[[1]])
pt.red = SpatialPoints(cbind(0.25, 0.25))
points(pt.red, col = 'red', pch = 1)
```

The first case is when the grid cell data represent
point support values at the grid cell centre, which
is identical to case `i1` above:
```{r}
sf = SpatialField(as(sgdf, "SpatialPointsDataFrame"), sgdf)
i5 = interpolate(r~1, sf, SpatialField(pt.red, sgdf))
as(i5[1,], "data.frame")
```
The second case, grid cells represent constant area with
point support value, meaning that every point location within
a grid cell has the value of the grid cell assigned:
```{r}
sf = SpatialField(sgdf, sgdf, cellsArePoints = TRUE)
i6 = interpolate(r~1, sf, SpatialField(pt.red, sgdf))
as(i6[1,], "data.frame")
```
as case (...) above, we can predict a mean value for a grid cell by
```{r}
gt = GridTopology(cellcentre.offset = c(.25,.25), cellsize = c(1,1), cells.dim = c(1,1))
grd.red = SpatialGrid(gt)
i7 = interpolate(r~1, sf, SpatialAggregation(grd.red))
i7@observations@data
```

### Area-to-point kriging
```{r}
sp = as(sgdf, "SpatialPolygonsDataFrame")
gf = SpatialAggregation(sp)
library(gstat)
kr = interpolate(r~1, gf, SpatialField(pt.red, sp), 
	vgm = vgm(1, "Exp", 5, 0))
kr@observations[[1]]
krige0(r ~ 1, sp, pt.red, vgmArea, vgm = vgm(1, "Exp", 5, 0))
```

### Grid-to-grid kriging
```{r}
sp = as(sgdf, "SpatialPolygonsDataFrame")
gr = as(grd.red, "SpatialPolygons")
grd = addAttrToGeom(gr, data.frame(r=0), FALSE)
plot(as(sgdf, "SpatialPolygons"), axes = TRUE)
text(coordinates(sgdf), labels = sgdf[[1]])
plot(grd, add = TRUE, border = 'red')
kr = interpolate(r~1, gf, SpatialAggregation(grd), 
	vgm = vgm(1, "Exp", 5, 0))
kr@observations[[1]]
krige0(r ~ 1, sp, grd, vgmArea, vgm = vgm(1, "Exp", 5, 0))
```

## Estimating density from entitities
For `SpatialEntity` objects, we can estimate the density of objects; this
method reuses `MASS:kde2d`:
```{r}
e = SpatialEntities(meuse, meuse.area)
d = density(e, newdata = meuse.grid)
lt = list(list("sp.polygons", meuse.area, border = 'black',
	first=FALSE), list("sp.points", meuse, col = grey(.5), pch = 16))
spplot(d, sp.layout = lt)
```

## Spatial Aggregation

### for `SpatialField` data
```{r}
m = SpatialField(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(meuse.area), mean) # no warning
a[[1]]
a = aggregate(m, SpatialAggregation(meuse.area), sum) # warns:
a[[1]]
```

### for `SpatialEntity` data
```{r}
m = SpatialEntities(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(meuse.area), mean) # warns:
a[[1]]
a = aggregate(m, SpatialAggregation(meuse.area), sum) # no warning
a[[1]]
```

# Meaningful warnings

Pebesma et al. ([2014](https://agu.confex.com/agu/fm14/meetingapp.cgi#Paper/3289))
make assertions A1-A7. 

## A1. 
**A prediction is meaningful, if it provides an estimate for a potential observation
Prediction on a field variable generates no warning.**

Where prediction of a `SpatialField` varialbe generates no warning,
```{r}
m = SpatialField(meuse, meuse.area) # data are point support
i1 = interpolate(log(zinc)~1, m) # interpolate from point TO point support
```
prediction of a point pattern variable generates a warning:
```{r}
m = SpatialEntities(meuse, meuse.area)
sa = SpatialAggregation(meuse.grid)
i1 = interpolate(log(zinc)~1, m, sa) # interpolate point pattern variable: warns
```
## A2. 
**Summing up values over an area is meaningful, if the observed window corresponds to the target geometry (grouping predicate) of the aggregation.**

For `SpatialEntity` data, spatial aggregation over an area larger than the 
observation window generates a warning:
```{r}
x = bbox(meuse)[1,]
y = bbox(meuse)[2,]
bb = Polygon(cbind(c(x[1],x[1],x[2],x[2],x[1]), c(y[1],y[2],y[2],y[1],y[1])))
bbx = SpatialPolygons(list(Polygons(list(bb),"bbox_meuse")),
	proj4string = CRS(proj4string(meuse)))
m = SpatialEntities(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(bbx), sum) # warns:
```
Stasch et al. [2014](http://www.sciencedirect.com/science/article/pii/S1364815213001977)
prove A1 and A2 more formally.

Further assertions in the poster:
## A3.
**Polygon data may reflect constant values over areas (geology) or means 
(population density), this matters for (further) aggregation or downsampling.**

Package `mss` distinguishes between `SpatialField` and
`SpatialAggregations` to represent constant values, and aggregations,
respectively. Subsampling `SpatialField` variabls does not not warn,
```{r}
area = addAttrToGeom(meuse.area, data.frame(v=1), match.ID = FALSE)
f = SpatialField(area, meuse.area)
pts = SpatialField(meuse[1:5,], meuse.area)
over(pts, f) # retrieve f at the points of pts:
```
but subsampling `SpatialAggregation` variables triggers a warning, and no
useful value
```{r}
a = SpatialAggregation(area)
over(pts, a)
```
as it should really disaggregate first, from area to point.

## A4.
**The same is true for grid cells.**

`SpatialField` and `SpatialAggregation` both generalize polygon and grid data.
```{r}
f1 = SpatialField(meuse.grid, meuse.area, cellsArePoints = TRUE)
pts = SpatialField(meuse[1:5,], meuse.area)
over(pts, f1) # matches pts to grid cell center points:
f2 = SpatialField(meuse.grid, meuse.area, cellsArePoints = FALSE)
over(pts, f2) # matches pts to the complete grid cell
a = SpatialAggregation(meuse.grid)
over(pts, a)
```

## A5. 
**Point pattern data often come without observation window, over which aggregation is meaningful**

Attempting to create a `SpatialEntities` object without an observation window leads to a warning, followed by an error:
```{r}
tr = try(pts <- SpatialEntities(meuse))
attr(tr, "condition")
```

## A6. 
**Field measurements often come without a notion for which locations interpolations based on them make sense.**

```{r}
m = SpatialField(meuse["zinc"], meuse.area)
a = interpolate(log(zinc)~1, m, SpatialAggregation(bbx)) # warns:
```

## A7. 
**File types do not inform on meaningfulness**

`SpatialPoints`, `SpatialPixels`, `SpatialGrid`, `SpatialLines`,
`SpatialPolygons` and their `*DataFrame` counterparts do not inform
whether data concern fields (geostatistical data), entities (point
patterns), or aggregations. The classes in `mss`: `SpatialField`,
`SpatialEntities`, and `SpatialAggregation`, do.

## References
1. E. Pebesma, C. Stasch, B. Gräler and S. Scheider, 2014.  Meaningfully Integrating Big Earth Science Data; AGU fall meeting, poster [IN33A-3757](https://agu.confex.com/agu/fm14/meetingapp.cgi#Paper/3289) [pdf](https://agu.confex.com/data/handout/agu/fm14/Paper_3289_handout_1504_0.pdf)
2. Stasch, C., S. Scheider, E. Pebesma, W. Kuhn, 2014.  Meaningful Spatial Prediction and Aggregation.  Environmental Modelling \& Software, 51, 149-165 [open access](http://www.sciencedirect.com/science/article/pii/S1364815213001977).
