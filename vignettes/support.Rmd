<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Spatial and spatio-temporal objects in Google charts}
-->

# Meaningful Spatial Statistics: The `mss` R Package

```{r}
library(mss) # meaningful spatial statistics
```

## Support, Domain, and Observation Window
This document introduces three classes for spatial data:
`SpatialField` and `SpatialEntities`, for representing spatial
fields, and entities, respectively, and `SpatialAggregation` for
spatial aggregations over fields and/or entities. 

# Domain and observation windows
The window class defines an area, either represented by a grid or by a polygon:
```{r}
showClass("Window")
```
and it is used to define a domain for a `SpatialField` object, or the
observation window for a `SpatialEntities` object.

After loading `sp`, we can import several objects
related to the `meuse` data set:
```{r}
library(sp)
demo(meuse, ask = FALSE, echo = FALSE)
sapply(ls(), function(x) class(get(x)))
```
we can define a window for the observation points data 
set by the `meuse.grid` data,
```{r}
w2 = Window(area = meuse.grid) # note the grid is passed, not the polygons
```
or by using the area as single polygon:
```{r}
w1 = Window(area = meuse.area)
```

We define spatial data objects as either fields having an observation
domain, entities having an observation window, or aggregations:
```{r}
showClass("SpatialField")
showClass("SpatialEntities")
showClass("SpatialAggregation")
```

## Interpolation

### interpolation of point support data
We can predict to points, laid out regularly, inside a polygon
```{r}
m = SpatialField(meuse, meuse.area) # data are point support
i1 = interpolate(log(zinc)~1, m) # interpolate from point TO point support
spplot(i1, "var1.pred")
```

or we can predict the polygon area mean value:
```{r}
library(rgeos)
m2 = SpatialAggregation(meuse.area)
i2 = interpolate(log(zinc)~1, m, m2) # interpolate from point TO polygon support
i2$var1.pred # a single value, estimate of mean for the whole area
mean(log(m$zinc)) # sample mean
mean(i1$var1.pred) # mean of predictions, similar to i2$var1.pred
```
We can repeat this with a domain, defined by the `meuse.grid` object, by
predicting to point support values for points on a grid
```{r}
m = SpatialField(meuse, meuse.grid)
i3 = interpolate(log(zinc)~1, m)
print(as(i3[1:3,], "data.frame"), digits = 10) # point support
```
or predict values for cell means:
```{r}
m4 = SpatialAggregation(meuse.grid)
i4 = interpolate(log(zinc)~1, m, m4) # interpolate from point TO feature (cell) support
print(as(i4[1:3,], "data.frame"), digits = 10) # grid cells support
spplot(i4, "var1.pred")
```

### Support of the feature
Suppose we have grid data on a 3 x 3 grid, and
want to estimate on a new location, indicated by a red
circle:
```{r}
set.seed(131)
gt = GridTopology(cellcentre.offset = c(0,0), cellsize = c(1,1), cells.dim = c(3,3))
sgdf = SpatialGridDataFrame(SpatialGrid(gt), 
	data.frame(r = round(runif(9, max = 10), 1)))
plot(as(sgdf, "SpatialPolygons"), axes = TRUE)
text(coordinates(sgdf), labels = sgdf[[1]])
pt.red = SpatialPoints(cbind(0.25, 0.25))
points(pt.red, col = 'red', pch = 1)
```

The first case is when the grid cell data represent
point support values at the grid cell centre, which
is identical to case `i1` above:
```{r}
sf = SpatialField(as(sgdf, "SpatialPointsDataFrame"), sgdf)
i5 = interpolate(r~1, sf, SpatialField(pt.red, sgdf))
as(i5[1,], "data.frame")
```
The second case, grid cells represent constant area with
point support value, meaning that every point location within
a grid cell has the value of the grid cell assigned:
```{r}
sf = SpatialField(sgdf, sgdf)
i6 = interpolate(r~1, sf, SpatialField(pt.red, sgdf))
as(i6[1,], "data.frame")
```
as case (...) above, we can predict a mean value for a grid cell by
```{r}
gt = GridTopology(cellcentre.offset = c(.25,.25), cellsize = c(1,1), cells.dim = c(1,1))
grd.red = SpatialGrid(gt)
i7 = interpolate(r~1, sf, SpatialAggregation(grd.red))
i7@observations@data
```

### Area-to-point kriging
```{r}
sp = as(sgdf, "SpatialPolygonsDataFrame")
gf = SpatialAggregation(sp)
library(gstat)
kr = interpolate(r~1, gf, SpatialField(pt.red, sp), 
	vgm = vgm(1, "Exp", 5, 0))
kr@observations[[1]]
krige0(r ~ 1, sp, pt.red, vgm_area, vgm = vgm(1, "Exp", 5, 0))
```

### Grid-to-grid kriging
```{r}
sp = as(sgdf, "SpatialPolygonsDataFrame")
gr = as(grd.red, "SpatialPolygons")
grd = addAttrToGeom(gr, data.frame(r=0), FALSE)
plot(as(sgdf, "SpatialPolygons"), axes = TRUE)
text(coordinates(sgdf), labels = sgdf[[1]])
plot(grd, add = TRUE, border = 'red')
kr = interpolate(r~1, gf, SpatialAggregation(grd), 
	vgm = vgm(1, "Exp", 5, 0))
kr@observations[[1]]
krige0(r ~ 1, sp, grd, vgm_area, vgm = vgm(1, "Exp", 5, 0))
```

## Estimating density from entitities
For `SpatialEntity` objects, we can estimate the density of objects; this
method reuses `MASS:kde2d`:
```{r}
e = SpatialEntities(meuse, meuse.area)
d = density(e, newdata = meuse.grid)
lt = list(list("sp.polygons", meuse.area, border = 'black',
	first=FALSE), list("sp.points", meuse, col = grey(.5), pch = 16))
spplot(d, sp.layout = lt)
```

## Spatial Aggregation

### for `SpatialField` data
```{r}
m = SpatialField(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(meuse.area), mean) # no warning
a[[1]]
a = aggregate(m, SpatialAggregation(meuse.area), sum) # warns:
a[[1]]
```

### for `SpatialEntity` data
```{r}
m = SpatialEntities(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(meuse.area), mean) # warns:
a[[1]]
a = aggregate(m, SpatialAggregation(meuse.area), sum) # no warning
a[[1]]
```

# Meaningful warnings

Pebesma et al. ([2014](https://agu.confex.com/agu/fm14/meetingapp.cgi#Paper/3289))
make assertions A1-A7. 

## A1. 
**A prediction is meaningful, if it provides an estimate for a potential observation
Prediction on a field variable generates no warning.**

Where prediction of a `SpatialField` varialbe generates no warning,
```{r}
m = SpatialField(meuse, meuse.area) # data are point support
i1 = interpolate(log(zinc)~1, m) # interpolate from point TO point support
```
prediction of a point pattern variable generates a warning:
```{r}
m = SpatialEntities(meuse, meuse.area)
sa = SpatialAggregation(meuse.grid)
i1 = interpolate(log(zinc)~1, m, sa) # interpolate point pattern variable: warns
```
## A2. 
**Summing up values over an area is meaningful, if the observed window corresponds to the target geometry (grouping predicate) of the aggregation.**

For `SpatialEntity` data, spatial aggregation over an area larger than the 
observation window generates a warning:
```{r}
x = bbox(meuse)[1,]
y = bbox(meuse)[2,]
bb = Polygon(cbind(c(x[1],x[1],x[2],x[2],x[1]), c(y[1],y[2],y[2],y[1],y[1])))
bbx = SpatialPolygons(list(Polygons(list(bb),"bbox_meuse")),
	proj4string = CRS(proj4string(meuse)))
m = SpatialEntities(meuse["zinc"], meuse.area)
a = aggregate(m, SpatialAggregation(bbx), sum) # warns:
```
Stasch et al. [2014](http://www.sciencedirect.com/science/article/pii/S1364815213001977)
prove A1 and A2 more formally.

Further assertions in the poster:
## A3.
**Polygon data may reflect constant values over areas (geology) or means (population density), this matters for (further) aggregation or downsampling.**

Package `mss` distinguishes between `SpatialField` and
`SpatialAggregations` to represent constant values, and aggregations,
respectively. Subsampling `SpatialField` variabls does not not warn,
```{r}
area = addAttrToGeom(meuse.area, data.frame(v=1), match.ID = FALSE)
f = SpatialField(area, meuse.area)
pts = SpatialField(meuse, meuse.area)
x1 = over(pts, f)
```
but subsampling `SpatialAggregation` variables triggers a warning:
```{r}
a = SpatialAggregation(area)
x2 = over(pts, a)
```

## A4.
**The same is true for grid cells.**

`SpatialField` and `SpatialAggregation` both generalize polygon and grid data:
```{r}
f = SpatialField(meuse.grid, meuse.area)
pts = SpatialField(meuse, meuse.area)
a = SpatialAggregation(meuse.grid)
x1 = over(pts, f)
x2 = over(pts, a)
```

## A5. 
**Point pattern data often come without observation window, over which aggregation is meaningful**

Attempting to create a `SpatialEntities` object without an observation window leads to a warning, followed by an error:
```{r}
tr = try(pts <- SpatialEntities(meuse))
attr(tr, "condition")
```

## A6. 
**Field measurements often come without a notion for which locations interpolations based on them make sense.**

```{r}
m = SpatialField(meuse["zinc"], meuse.area)
a = interpolate(log(zinc)~1, m, SpatialAggregation(bbx)) # warns:
```

## A7. 
**File types do not inform on meaningfulness**

`SpatialPoints`, `SpatialPixels`, `SpatialGrid`, `SpatialLines`,
`SpatialPolygons` and their `*DataFrame` counterparts do not inform
whether data concern fields (geostatistical data), entities (point
patterns), or aggregations. The classes in `mss`: `SpatialField`,
`SpatialEntities`, and `SpatialAggregation`, do.

## References
1. E. Pebesma, C. Stasch, B. GrÃ¤ler and S. Scheider, 2014.  Meaningfully Integrating Big Earth Science Data; AGU fall meeting, poster [IN33A-3757](https://agu.confex.com/agu/fm14/meetingapp.cgi#Paper/3289) [pdf](https://agu.confex.com/data/handout/agu/fm14/Paper_3289_handout_1504_0.pdf)
2. Stasch, C., S. Scheider, E. Pebesma, W. Kuhn, 2014.  Meaningful Spatial Prediction and Aggregation.  Environmental Modelling \& Software, 51, 149-165 [open access](http://www.sciencedirect.com/science/article/pii/S1364815213001977).
